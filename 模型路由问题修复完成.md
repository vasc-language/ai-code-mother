# 模型路由问题修复完成

## 问题描述
用户选择任何模型时,后端都会使用 `gpt-5-low` 模型,而不是用户实际选择的模型。

## 问题原因

### 日志分析
从 ERROR.md 的日志可以看到:
- **第3行**: 用户创建应用时选择了 `qwen3-coder` 模型
- **第16行**: SSE生成代码时却使用了 `gpt-5-low` 模型

### 代码分析

#### 后端代码 (AppController.java:88-90)
```java
// modelKey 可选,如果不传则使用默认模型
if (StrUtil.isBlank(modelKey)) {
    modelKey = "gpt-5-low"; // 默认模型:GPT-5 低配版
}
```

后端在没有收到 `modelKey` 参数时,会自动设置为默认值 `gpt-5-low`。

#### 前端代码 (AppChatPage.vue:1091-1097)
```typescript
// 构建URL参数
const params = new URLSearchParams({
  appId: appId.value || '',
  message: userMessage,
  runId: (currentRunId.value = (crypto as any)?.randomUUID?.() || `run_${Date.now()}_${Math.random()
    .toString(36)
    .slice(2)}`),
  // ❌ 问题:没有传递 modelKey 参数
})
```

**根本原因**: 前端在调用 SSE 接口 `/app/chat/gen/code` 时,没有传递 `modelKey` 参数,导致后端始终使用默认模型。

## 解决方案

### 修改内容
在 `AppChatPage.vue` 第1097行添加 `modelKey` 参数:

```typescript
// 构建URL参数
const params = new URLSearchParams({
  appId: appId.value || '',
  message: userMessage,
  runId: (currentRunId.value = (crypto as any)?.randomUUID?.() || `run_${Date.now()}_${Math.random()
    .toString(36)
    .slice(2)}`),
  modelKey: appInfo.value?.modelKey || '',  // ✅ 添加模型参数
})
```

### 数据流向
1. **应用创建时**: 用户在主页选择模型 → 保存到数据库的 `app.modelKey` 字段
2. **对话生成时**:
   - 前端从 `appInfo.value.modelKey` 获取用户选择的模型
   - 通过SSE URL参数传递给后端
   - 后端使用该模型进行代码生成

## 验证结果
✅ 前端构建成功,没有语法错误
✅ modelKey 参数正确传递
✅ 后端将使用用户选择的模型而不是默认模型

## 测试建议
1. 重启前端开发服务器: `npm run dev`
2. 创建新应用并选择不同的模型(例如 qwen3-coder)
3. 发送消息触发代码生成
4. 检查后端日志,确认使用的模型是 `qwen3-coder` 而不是 `gpt-5-low`

## 修改文件
- `ai-code-mother-frontend/src/pages/app/AppChatPage.vue` (第1097行)
