结合你的核心目标——**通过积分限制大模型API费用过度消耗（防刷）**，积分设计需与**实际Token消耗成本强绑定**，因此**按Token用量计算积分更合适**，具体设计如下：


### 一、核心逻辑：积分与Token消耗直接挂钩
#### 1. 生成应用的积分成本 = Token预估消耗 × 积分兑换比例
- **原理**：大模型API费用直接由Token消耗决定（参考代码中`AiModelMetricsCollector`对`ai_model_tokens_total`的统计），积分消耗与Token用量绑定，可精准映射平台成本，从根源上防止“低成本高消耗”的刷量行为。
- **举例**：设定1积分 = 100 Token，生成一个预估消耗5000 Token的应用需消耗50积分。实际生成时按**真实Token消耗**多退少补（避免用户因预估偏差吃亏）。


#### 2. 积分获取与Token消耗的联动限制
- **每日签到**：仅发放少量固定积分（如5积分 = 500 Token），避免通过签到获取大量免费Token。
- **邀请奖励**：被邀请用户消耗Token时，邀请者获得一定比例积分（如被邀请者消耗1000 Token，邀请者得1积分），既激励邀请真实用户，又确保奖励与平台成本联动（被邀请者不消耗Token则无奖励）。


### 二、防刷规则强化（结合现有技术方案）
1. **基于Token消耗的动态限流**  
   复用`RateLimitAspect`的限流能力，对积分兑换Token的行为按用户/IP设置阈值（如单用户每日最多兑换10万Token = 1000积分），避免短期大量消耗。

2. **无效生成的积分扣减**  
   若生成的应用未通过“有效判定”（如内容为空、重复生成、触发安全过滤），不仅不返还积分，还额外扣减少量积分（如5积分），抑制恶意刷生成行为。  
   *（有效判定可参考`AppServiceImpl`中对应用生成结果的校验逻辑）*

3. **阶梯式积分成本**  
   对单用户单日Token消耗量设置阶梯：
  - 0-10万Token：1积分=100 Token（正常比例）
  - 10万-50万Token：1积分=80 Token（成本提升，抑制超额使用）
  - 50万以上：1积分=50 Token（大幅提升成本，限制重度刷量）


### 三、为何不选“按应用个数”？
- **漏洞风险**：用户可通过创建大量低Token消耗的“垃圾应用”（如仅生成一行代码）消耗积分，绕过Token限制，导致平台API费用浪费（每个应用即使消耗100 Token，1000个应用也会产生10万Token成本）。
- **与成本脱节**：应用个数无法反映实际Token消耗（一个复杂应用可能消耗10万Token，而10个简单应用可能仅消耗1万Token），无法精准控制成本。


### 四、实现可行性（复用现有代码能力）
1. **Token统计**：直接使用`AiModelMetricsCollector`的`recordTokenUsage`方法，实时获取用户生成应用时的Token消耗，无需额外埋点。
2. **积分与Token映射**：在生成流程（`AppServiceImpl`的`chatToGenCode`方法）中，先校验用户积分是否足够覆盖预估Token消耗，生成完成后按实际消耗扣减积分。
3. **监控与告警**：通过`ai_model_tokens_total`指标（参考`ai_model_grafana_config.json`）监控积分与Token消耗的比例，异常时触发告警（如某用户积分消耗远低于Token消耗，可能存在刷量）。



### review
- 梳理应用版本管理控制层到服务层的调用链，补充权限校验步骤。
- 确认旧版本使用 app.getUserId().equals(...) 触发 NPE，部署不会修复缺失 userId 的应用数据。
- 给出处理建议：修复历史数据或升级到 Objects.equals 写法后重新部署。
